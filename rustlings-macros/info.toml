format_version = 1

welcome_message = """
Is this your first time? Don't worry, Rustlings is made for beginners!
We are going to teach you a lot of things about Rust, but before we can
get started, here are some notes about how Rustlings operates:

1. The central concept behind Rustlings is that you solve exercises. These
   exercises usually contain some compiler or logic errors which cause the
   exercise to fail compilation or testing. It's your job to find all errors
   and fix them!
2. Make sure to have your editor open in the `rustlings/` directory. Rustlings
   will show you the path of the current exercise under the progress bar. Open
   the exercise file in your editor, fix errors and save the file. Rustlings
   will automatically detect the file change and rerun the exercise. If all
   errors are fixed, Rustlings will ask you to move on to the next exercise.
3. If you're stuck on an exercise, enter `h` to show a hint.
4. If an exercise doesn't make sense to you, feel free to open an issue on
   GitHub! (https://github.com/rust-lang/rustlings). We look at every issue, and
   sometimes, other learners do too so you can help each other out!"""

final_message = """
We hope you enjoyed learning about the various aspects of Rust!
If you noticed any issues, don't hesitate to report them on Github.
You can also contribute your own exercises to help the greater community!

Before reporting an issue or contributing, please read our guidelines:
https://github.com/rust-lang/rustlings/blob/main/CONTRIBUTING.md"""

# VARIABLES

[[exercises]]
name = "variables1"
dir = "01_variables"
test = false
hint = """
The declaration in the `main` function is missing a keyword that is needed
in Rust to create a new variable binding."""

[[exercises]]
name = "variables4"
dir = "01_variables"
test = false
hint = """
In Rust, variable bindings are immutable by default. But here, we're trying
to reassign a different value to `x`! There's a keyword we can use to make
a variable binding mutable instead."""

[[exercises]]
name = "variables5"
dir = "01_variables"
test = false
hint = """
In `variables4` we already learned how to make an immutable variable mutable
using a special keyword. Unfortunately this doesn't help us much in this
exercise because we want to assign a different typed value to an existing
variable. Sometimes you may also like to reuse existing variable names because
you are just converting values to different types like in this exercise.

Fortunately Rust has a powerful solution to this problem: 'Shadowing'!
You can read more about 'Shadowing' in the book's section 'Variables and
Mutability':
https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html#shadowing

Try to solve this exercise afterwards using this technique."""

# FUNCTIONS

[[exercises]]
name = "functions1"
dir = "02_functions"
test = false
hint = """
This `main` function is calling a function that it expects to exist, but the
function doesn't exist. It expects this function to have the name `call_me`.
It also expects this function to not take any arguments and not return a value.
Sounds a lot like `main`, doesn't it?"""

[[exercises]]
name = "functions5"
dir = "02_functions"
test = false
hint = """
This is a really common error that can be fixed by removing one character.
It happens because Rust distinguishes between expressions and statements:
Expressions return a value based on their operand(s), and statements simply
return a `()` type which behaves just like `void` in C/C++.

We want to return a value with the type `i32` from the `square` function, but
it is returning the type `()`.

There are two solutions:
1. Add the `return` keyword before `num * num;`
2. Remove the semicolon `;` after `num * num`"""

# QUIZ 1

[[exercises]]
name = "quiz1"
dir = "quizzes"
hint = "No hints this time ;)"

# PRIMITIVE TYPES

[[exercises]]
name = "primitive_types3"
dir = "04_primitive_types"
test = false
hint = """
There's a shorthand to initialize arrays with a certain size that doesn't
require you to type in 100 items (but you certainly can if you want!).

For example, you can do:
```
let array = ["Are we there yet?"; 100];
```"""

[[exercises]]
name = "primitive_types5"
dir = "04_primitive_types"
test = false
hint = """
Take a look at the 'Data Types -> The Tuple Type' section of the book:
https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type
Particularly the part about destructuring (second to last example in the
section).

You'll need to make a pattern to bind `name` and `age` to the appropriate parts
of the tuple."""

# STRINGS

[[exercises]]
name = "strings1"
dir = "09_strings"
test = false
hint = """
The `current_favorite_color` function is currently returning a string slice
with the `'static` lifetime. We know this because the data of the string lives
in our code itself -- it doesn't come from a file or user input or another
program -- so it will live as long as our program lives.

But it is still a string slice. There's one way to create a `String` by
converting a string slice covered in the Strings chapter of the book, and
another way that uses the `From` trait."""

[[exercises]]
name = "strings2"
dir = "09_strings"
test = false
hint = """
Yes, it would be really easy to fix this by just changing the value bound to
`word` to be a string slice instead of a `String`, wouldn't it? There is a way
to add one character to the `if` statement, though, that will coerce the
`String` into a string slice.

Side note: If you're interested in learning about how this kind of reference
conversion works, you can jump ahead in the book and read this part in the
smart pointers chapter:
https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods"""

[[exercises]]
name = "strings4"
dir = "09_strings"
test = false
hint = """
Replace `placeholder` with either `string` or `string_slice` in the `main`
function.

Example:
`placeholder("blue");`
should become
`string_slice("blue");`
because "blue" is `&str`, not `String`."""

# VECS

[[exercises]]
name = "vecs1"
dir = "05_vecs"
hint = """
In Rust, there are two ways to define a Vector.
1. One way is to use the `Vec::new()` function to create a new vector
   and fill it with the `push()` method.
2. The second way is to use the `vec![]` macro and define your elements
   inside the square brackets. This way is simpler when you exactly know
   the initial values.

Check this chapter: https://doc.rust-lang.org/book/ch08-01-vectors.html
of the Rust book to learn more."""

[[exercises]]
name = "vecs2"
dir = "05_vecs"
hint = """
Use the `.push()` method on the vector to push new elements to it."""

# MOVE SEMANTICS

[[exercises]]
name = "move_semantics2"
dir = "06_move_semantics"
hint = """
When running this exercise for the first time, you'll notice an error about
"borrow of moved value". In Rust, when an argument is passed to a function and
it's not explicitly returned, you can't use the original variable anymore.
We call this "moving" a variable. When we pass `vec0` into `fill_vec`, it's
being "moved" into `vec1`, meaning we can't access `vec0` anymore.

You could make another, separate version of the data that's in `vec0` and
pass it to `fill_vec` instead. This is called cloning in Rust."""

[[exercises]]
name = "move_semantics4"
dir = "06_move_semantics"
hint = """
Carefully reason about the range in which each mutable reference is in
scope. Does it help to update the value of `x` immediately after
the mutable reference is taken?
Read more about 'Mutable References' in the book's section 'References and
Borrowing':
https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references."""

# STRUCTS

[[exercises]]
name = "structs3"
dir = "07_structs"
hint = """
For `is_international`: What makes a package international? Seems related to
the places it goes through right?

For `get_fees`: This method takes an additional argument, is there a field in
the `Package` struct that this relates to?

Have a look in The Book to find out more about method implementations:
https://doc.rust-lang.org/book/ch05-03-method-syntax.html"""

# ENUMS

[[exercises]]
name = "enums1"
dir = "08_enums"
test = false
hint = "No hints this time ;)"

[[exercises]]
name = "enums2"
dir = "08_enums"
test = false
hint = """
You can create enumerations that have different variants with different types
such as anonymous structs, structs, a single string, tuples, no data, etc."""

# MODULES

# HASHMAPS

# QUIZ 2

# OPTIONS

[[exercises]]
name = "options1"
dir = "12_options"
hint = """
Options can have a `Some` value, with an inner value, or a `None` value,
without an inner value.

There are multiple ways to get at the inner value, you can use `unwrap`, or
pattern match. Unwrapping is the easiest, but how do you do it safely so that
it doesn't panic in your face later?"""

# ERROR HANDLING

[[exercises]]
name = "errors3"
dir = "13_error_handling"
test = false
hint = """No hints this time ;)"""

# GENERICS

# TRAITS

[[exercises]]
name = "traits5"
dir = "15_traits"
hint = """
To ensure a parameter implements multiple traits use the '+ syntax'. Try
replacing `???` with 'impl [what goes here?] + [what goes here?]'.

Related section in The Book:
https://doc.rust-lang.org/book/ch10-02-traits.html#specifying-multiple-trait-bounds-with-the--syntax"""

# QUIZ 3

# LIFETIMES

# TESTS

# STANDARD LIBRARY TYPES

# SMART POINTERS

# THREADS

# MACROS

#  CLIPPY

# TYPE CONVERSIONS
